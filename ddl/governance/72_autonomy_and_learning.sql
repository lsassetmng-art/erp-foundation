-- ============================================================
-- Phase13: autonomy auto + learning feedback + dashboard + SLA watcher (idempotent)
-- ============================================================

CREATE SCHEMA IF NOT EXISTS governance;
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- ---- autonomy_config : 既存に合わせて不足列を足す（安全）
DO $$
BEGIN
  IF to_regclass('governance.autonomy_config') IS NULL THEN
    CREATE TABLE governance.autonomy_config (
      autonomy_id     bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      autonomy_mode   text NOT NULL DEFAULT 'manual', -- manual|auto
      min_confidence  numeric(6,3) NOT NULL DEFAULT 0.900,
      max_risk_score  numeric(10,3) NOT NULL DEFAULT 0.200,
      require_dryrun_ok boolean NOT NULL DEFAULT true,
      updated_at      timestamptz NOT NULL DEFAULT now()
    );
    INSERT INTO governance.autonomy_config(autonomy_mode) VALUES ('manual');
  ELSE
    -- 既存テーブルに列が無ければ追加
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='governance' AND table_name='autonomy_config' AND column_name='autonomy_mode')
    THEN ALTER TABLE governance.autonomy_config ADD COLUMN autonomy_mode text NOT NULL DEFAULT 'manual'; END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='governance' AND table_name='autonomy_config' AND column_name='min_confidence')
    THEN ALTER TABLE governance.autonomy_config ADD COLUMN min_confidence numeric(6,3) NOT NULL DEFAULT 0.900; END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='governance' AND table_name='autonomy_config' AND column_name='max_risk_score')
    THEN ALTER TABLE governance.autonomy_config ADD COLUMN max_risk_score numeric(10,3) NOT NULL DEFAULT 0.200; END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='governance' AND table_name='autonomy_config' AND column_name='require_dryrun_ok')
    THEN ALTER TABLE governance.autonomy_config ADD COLUMN require_dryrun_ok boolean NOT NULL DEFAULT true; END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='governance' AND table_name='autonomy_config' AND column_name='updated_at')
    THEN ALTER TABLE governance.autonomy_config ADD COLUMN updated_at timestamptz NOT NULL DEFAULT now(); END IF;
  END IF;
END $$;

-- ---- 学習用：自律の調整履歴（結果→閾値更新を記録）
CREATE TABLE IF NOT EXISTS governance.autonomy_tuning_log (
  tuning_id   uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tuned_at    timestamptz NOT NULL DEFAULT now(),
  before_min_conf numeric(6,3),
  before_max_risk  numeric(10,3),
  after_min_conf  numeric(6,3),
  after_max_risk   numeric(10,3),
  window_applied   int,
  window_failed    int,
  note text
);

-- ---- policy_apply_queue が無い場合は作る（あなたの現状だと既に存在しているはず）
DO $$
BEGIN
  IF to_regclass('governance.policy_apply_queue') IS NULL THEN
    CREATE TABLE governance.policy_apply_queue (
      apply_id     bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      requested_at timestamptz NOT NULL DEFAULT now(),
      requested_by text        NOT NULL DEFAULT current_user,
      source_policy_change_id bigint,
      title        text        NOT NULL,
      sql_text     text        NOT NULL,
      status       text        NOT NULL DEFAULT 'pending', -- pending|applied|rejected
      applied_at   timestamptz,
      last_error   text
    );
    CREATE INDEX policy_apply_queue_status_idx ON governance.policy_apply_queue(status, requested_at);
  END IF;
END $$;

-- ---- policy_approval_queue 前提（Phase7-12で作成済み想定）
-- 最低限: approval_id, status, title, sql_text(or apply_sql), confidence, risk_score, dryrun_status, created_at
-- ※列名が違う可能性があるので、存在チェック→使える列だけで動く関数にする

CREATE OR REPLACE FUNCTION governance.get_autonomy()
RETURNS TABLE(autonomy_mode text, min_confidence numeric, max_risk_score numeric, require_dryrun_ok boolean)
LANGUAGE sql
STABLE
AS $$
  SELECT
    (SELECT autonomy_mode FROM governance.autonomy_config ORDER BY updated_at DESC LIMIT 1),
    (SELECT min_confidence FROM governance.autonomy_config ORDER BY updated_at DESC LIMIT 1),
    (SELECT max_risk_score FROM governance.autonomy_config ORDER BY updated_at DESC LIMIT 1),
    (SELECT require_dryrun_ok FROM governance.autonomy_config ORDER BY updated_at DESC LIMIT 1)
$$;

-- ---- 自動承認→apply_queue投入（列名差異を吸収する）
CREATE OR REPLACE FUNCTION governance.auto_approve_and_enqueue(limit_n int DEFAULT 5)
RETURNS int
LANGUAGE plpgsql
AS $$
DECLARE
  v_mode text;
  v_min_conf numeric;
  v_max_risk numeric;
  v_need_dryrun boolean;
  v_cnt int := 0;

  has_sql_text boolean;
  has_apply_sql boolean;
  sql_col text;
BEGIN
  SELECT autonomy_mode, min_confidence, max_risk_score, require_dryrun_ok
    INTO v_mode, v_min_conf, v_max_risk, v_need_dryrun
  FROM governance.get_autonomy();

  IF v_mode IS DISTINCT FROM 'auto' THEN
    RETURN 0;
  END IF;

  IF to_regclass('governance.policy_approval_queue') IS NULL THEN
    RETURN 0;
  END IF;

  SELECT EXISTS(
    SELECT 1 FROM information_schema.columns
     WHERE table_schema='governance' AND table_name='policy_approval_queue' AND column_name='sql_text'
  ) INTO has_sql_text;

  SELECT EXISTS(
    SELECT 1 FROM information_schema.columns
     WHERE table_schema='governance' AND table_name='policy_approval_queue' AND column_name='apply_sql'
  ) INTO has_apply_sql;

  IF has_sql_text THEN
    sql_col := 'sql_text';
  ELSIF has_apply_sql THEN
    sql_col := 'apply_sql';
  ELSE
    -- 実SQL列が無いなら自動処理できない
    RETURN 0;
  END IF;

  -- pending のうち条件を満たすものを limited に処理
  EXECUTE format($q$
    WITH picked AS (
      SELECT approval_id, title, %1$I AS sql_text, confidence, risk_score, dryrun_status, created_at
      FROM governance.policy_approval_queue
      WHERE status = 'pending'
        AND confidence >= $1
        AND risk_score <= $2
        AND (NOT $3 OR coalesce(dryrun_status,'') IN ('ok','passed','pass'))
      ORDER BY created_at
      FOR UPDATE SKIP LOCKED
      LIMIT $4
    ),
    upd AS (
      UPDATE governance.policy_approval_queue q
        SET status='approved'
      FROM picked p
      WHERE q.approval_id = p.approval_id
      RETURNING p.approval_id, p.title, p.sql_text
    )
    INSERT INTO governance.policy_apply_queue(title, sql_text, source_policy_change_id)
      SELECT title, sql_text, NULL
      FROM upd
    RETURNING 1
  $q$, sql_col)
  USING v_min_conf, v_max_risk, v_need_dryrun, limit_n;

  GET DIAGNOSTICS v_cnt = ROW_COUNT;
  RETURN v_cnt;
END $$;

-- ---- 学習反映：直近N件の apply 成否から閾値を “少しだけ” 自動調整（安全側）
CREATE OR REPLACE FUNCTION governance.refresh_autonomy_thresholds(window_n int DEFAULT 50)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  before_min numeric;
  before_risk numeric;
  after_min numeric;
  after_risk numeric;
  applied_n int;
  failed_n int;
BEGIN
  SELECT min_confidence, max_risk_score INTO before_min, before_risk
  FROM governance.autonomy_config ORDER BY updated_at DESC LIMIT 1;

  SELECT
    count(*) FILTER (WHERE status='applied'),
    count(*) FILTER (WHERE status='rejected')
  INTO applied_n, failed_n
  FROM (
    SELECT status
    FROM governance.policy_apply_queue
    WHERE status IN ('applied','rejected')
    ORDER BY requested_at DESC
    LIMIT window_n
  ) s;

  -- 失敗が多いほど厳しく、成功が続けば緩める（ただし緩め過ぎない）
  after_min := before_min;
  after_risk := before_risk;

  IF failed_n >= 5 THEN
    after_min := LEAST(0.990, before_min + 0.020);
    after_risk := GREATEST(0.050, before_risk - 0.050);
  ELSIF failed_n = 0 AND applied_n >= 20 THEN
    after_min := GREATEST(0.800, before_min - 0.010);
    after_risk := LEAST(1.000, before_risk + 0.020);
  END IF;

  IF after_min IS DISTINCT FROM before_min OR after_risk IS DISTINCT FROM before_risk THEN
    UPDATE governance.autonomy_config
      SET min_confidence=after_min,
          max_risk_score=after_risk,
          updated_at=now();
    INSERT INTO governance.autonomy_tuning_log(
      before_min_conf, before_max_risk, after_min_conf, after_max_risk,
      window_applied, window_failed, note
    ) VALUES (
      before_min, before_risk, after_min, after_risk,
      applied_n, failed_n,
      'auto-tune by last window'
    );
  END IF;
END $$;

-- ---- ダッシュボード view（KPI + キュー状況）
CREATE OR REPLACE VIEW governance.v_ops_dashboard AS
WITH q AS (
  SELECT
    (SELECT count(*) FROM governance.policy_approval_queue WHERE status='pending') AS pending_approvals,
    (SELECT count(*) FROM governance.policy_apply_queue WHERE status='pending')    AS pending_applies,
    (SELECT count(*) FROM governance.policy_apply_queue WHERE status='rejected')   AS total_apply_rejected,
    (SELECT count(*) FROM governance.policy_apply_queue WHERE status='applied')    AS total_apply_applied
),
last24 AS (
  SELECT
    count(*) FILTER (WHERE status='applied')  AS applied_24h,
    count(*) FILTER (WHERE status='rejected') AS rejected_24h
  FROM governance.policy_apply_queue
  WHERE requested_at >= now() - interval '24 hours'
)
SELECT
  now() AS asof,
  q.*,
  last24.*,
  (SELECT autonomy_mode FROM governance.autonomy_config ORDER BY updated_at DESC LIMIT 1) AS autonomy_mode,
  (SELECT min_confidence FROM governance.autonomy_config ORDER BY updated_at DESC LIMIT 1) AS min_confidence,
  (SELECT max_risk_score FROM governance.autonomy_config ORDER BY updated_at DESC LIMIT 1) AS max_risk_score
FROM q, last24;

-- ---- SLA / 異常検知：イベント格納
CREATE TABLE IF NOT EXISTS governance.sla_alert_event (
  alert_id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at timestamptz NOT NULL DEFAULT now(),
  alert_type text NOT NULL,        -- queue_backlog|apply_fail_spike|other
  severity text NOT NULL DEFAULT 'warn', -- info|warn|crit
  message text NOT NULL,
  snapshot jsonb
);

CREATE INDEX IF NOT EXISTS sla_alert_event_created_idx ON governance.sla_alert_event(created_at DESC);
